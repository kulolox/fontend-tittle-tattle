## 你不知道的 JavaScript 上卷

### 编译过程：

- 分词/词法分析

将字符串分解成有意义的代码块，这些代码块被称为词法单元。

```
var a = 2; // var, a, =, 2, ; 空格是否被当做词法单元取决于空格在这门编程语言中是否有意义
```

- 解析/语法分析

生成抽象语法树，AST

- 代码生成

将 AST 转换为可执行的代码。

### 编译三巨头引擎、编译器、作用域（重点）

> 作用域：收集并维护由所声明标识符（变量）组成的一系列查询，并实施一套非常严格的标准，确定当前代码对这些标识符的访问权限。

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。

LHS：赋值操作的目标

RHS：赋值操作的源头

```
function foo(a) {
console.log(a)
}
foo(2)
// foo()函数调用对foo进行RHS查询，2参数传递进行隐式LHS查询，console查询RHS查询，注意函数foo的声明不是LHS查询
```

### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此在当前作用域无法找到某个变量时，引擎会在外层嵌套的作用域中查询，直到找到变量或抵达最外层作用域，此时无论是否找到，查询都将停止。

### 异常

区分 LHS 和 RHS 查询的目的

RHS: 在作用域链中找不到对应变量，引擎抛出 ReferenceError 错误。如果找到了，但错误调用，比如引用 undefined 或 null 类型值的属性，则抛出 TypeError 错误

LHS: 非严格模式中，如果在最顶层作用域中也无法找到变量，则会创建该变量。严格模式则抛出 ReferenceError 错误。

> ReferenceError 作用域判别失败，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的

### 词法作用域

词法作用域在词法化阶段就已经确定。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的。

> 有方法可以欺骗词法作用域，但是不推荐使用，要么就是没有实际意义，要么难以理解且无法优化编译过程。让词法作用域根据词法关系保持书写时的自然关系不变，是一个非常好的最佳实践

```
function foo(a) {
var b = a * 2;
function bar(c) {
console.log(a, b, c);
}
bar(b * 3);
}
foo(2); // 2, 4, 12
```

此段代码有 3 个作用域：

- 包含着整个代码的全局作用域，只有一个标识符：foo
- 包含着 foo 所创建的作用域，有 3 个标识符：a、bar、b
- 包含着 bar 所创建的作用域，只有一个标识符：c

作用域查找从当前作用域出发先外层查找，一旦找到第一个匹配项就停止，在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”。

> 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

### 函数作用域与块作用域

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。

我们可以在函数作用域中创建一个子作用域，那么子作用域中的所有变量和方法对于该作用域而言都是隐藏的。这种模式起因是最小特权原则。

隐藏作用域中的变量和函数还可以避免同名标识符之间的冲突。

应用：

- 全局命名空间，防止多个第三方库名在全局作用域中有冲突

函数作用域

函数有声明和表达式两种创建方式，最重要的区别是它们的名称标识符将会绑定在何处。

匿名函数缺点：

- 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
- 如果没有函数名，无法引用自身或者解绑函数
- 可读性差

优点：

- 简洁
- IIFE 及相关应用

块作用域

with、try/catch 的 catch 分句，let，const

### 提升

引擎会在解释 JavaScript 代码之前首先对其进行编译，编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。所有的声明将会被优先处理。

```
var a = 2;
// 声明在编译阶段阶段， var a = undefined;
// 赋值被留着原地等待 a = 2;
```

注意每个作用域都会进行提升操作，函数声明提升优先于变量声明。注意函数表达式模式不会被提升。

### 作用域闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即函数可以在定义时**词法作用域之外**执行。

```
function foo() {
var a = 2;
function bar() {
console.log(a); // 2
}
bar();
}
foo();
```

该例子有作用域嵌套，但是 bar 无法在 foo 以外调用，则不是闭包。

改造一下

```
function foo() {
var a = 2;
function bar() {
console.log(a); // 2
}
return bar
}
var baz = foo();
baz(); // 2, 这是闭包
```

bar()的词法作用域能够访问 foo()的内部作用域，我们将 bar 函数本身作为值传递，赋值给 baz，调用 baz 实际就是调用 bar，bar 可以在 foo 作用域以外调用。

拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

> 闭包使得函数可以访问定义时的词法作用域。

本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。

闭包的强大应用，模块

```
function CoolModule() {
var something = 'cool';
var another = [1, 2, 3];
function doSomething() {
console.log(something);
}
function doAnother() {
console.log(another);
}
return {
doSomething,
doAnother
}
}
var foo = CoolModule();
foo.doSomething();
foo.doAnother();
```

模块的必要条件：

- 必须有外部封装函数，且该函数至少被调用一次。
- 封装函数必须返回至少一个内部函数。

### this

函数可以在不同的环境下执行，因此需要一种机制能在函数体内部获得当前的运行环境，这就是 this。环境就是作用域。

变量的查询基于词法作用域，this 关注当前执行的作用域。

箭头函数，放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖 this 本来的值。
