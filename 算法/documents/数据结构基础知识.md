## 代码对数据的操作类型

- 找到要处理的数据，查找
- 把结果存到一个新内存空间中，新增
- 把结果存到一个已使用的内存空间中，需要先删除内存空间中已有的数据，再新增

## 数据结构

### 线性表

线性表是 n 个数据元素的有限序列，最常用的是链式表达，通常也叫做线性链表或者链表。在链表中存储的数据元素也叫做结点，一个结点存储一条数据记录。每个结点的结构包含两个部分：

- 第一是具体的数据值
- 第二是指向下一个结点的指针

链表的最前面通常有个头指针指向第一个结点，链表的最后一个结点，由于它之后没有下一个结点，因此它的指针是空指针。

链表只能通过上一个结点找到下一个结点，反过来是行不通的。因此也被称为单向链表。

有时为了弥补单项链表的不足，我们对链表进行改造：

- 对单向链表，让最后一个元素指针指向第一个元素，得到循环链表
- 改造结点，新增一个指向上一个结点的指针，得到双向链表
- 将循环链表与双向链表结合，得到双向循环链表

#### 增删查

链表在新增和删除数据都比较容易，可以在 O(1)的时间复杂度内完成，但对于查找则需要遍历全部数据，时间复杂度为 O(n)

虽然链表在新增和删除数据上有优势，但仔细思考，这个优势并不实用，他们都伴随一个查找动作。

链表的真正价值在于，它对数据的存储方式是按照顺序的存储，如果数据元素个数不定，且需要经常进行数据的新增和删除，链表比较合适。如果元素大小确定，删除插入的操作不多，那数组可能更适合。

### 栈

栈是一种特殊的线性表。栈与线性表的不同，体现在增和删的操作。具体而言，栈的数据结点必须后进先出。

栈既然也是线性表，它也包括表头和表尾，不过在栈结构中由于其操作的特殊性，会对表头和表尾的名字进行改造，表尾用来输入数据，通常叫做栈顶（top）；相应的表头就是栈底（bottom），栈有顺序表示和链式表示，分别称作顺序栈和链栈。

#### 基本操作

初始时，栈内没有数据，即空栈。此时栈顶就是栈底。对栈的新增操作，通常叫做 push 或压栈；对栈的删除操作，通常叫做 pop 或出栈。

### 队列

与栈类似，队列也是一种特殊的线性表，队列的特点是先进先出。队列也存在两种存储方式，即顺序队列和链式队列。顺序队列依赖数组实现，链表队列依赖链表实现，队头指针（front）指向链表的头结点，队尾指针(rear)指向终端结点，当队列为空时，队头队尾都指向头结点。队列从队头（front）删除元素，从队尾（rear）插入元素。

以顺序队列来看，当我们不断进行插入删除操作时，头尾两个指针都会不断向后移动。如果队列的空间不足，就会出现溢出现象。如果只是移动指针，则有可能出现假溢出现象。解决方案：

- 消耗 O(n)的时间复杂度去移动数据
- 开辟足够的内存空间，确保数组不会越界。

以上两个方法都不太友好，数组越界可以通过循环队列来解决。

#### 循环队列

循环队列新增数据时，需要判断队列是否为满。删除数据时则要判断队列是否为空

## 数组

数组是数据结构中的最基本结构。数组在内存中是连续存放的，数组内的数据，可以通过索引值直接取出得到。

数组在存储数据时是按顺序存储的，并且存储数据的内存也是连续的，这就造成了它具有增删困难、查找容易的特点。

数组增删查时间复杂度：

- 增加：若插入数据在最后，则时间复杂度为 O(1)；如果中间某处插入数据，则时间复杂度为 O(n)。
- 删除：对应位置的删除，扫描全数组，时间复杂度为 O(n)。
- 查找：如果只需根据索引值进行一次查找，时间复杂度是 O(1)。但是要在数组中查找一个数值满足指定条件的数据，则时间复杂度是 O(n)。

## 字符串

字符串（string） 是由 n 个字符组成的一个有序整体（ n >= 0 ）。

在实际操作中，我们经常会用到一些特殊的字符串：

- 空串：指含有零个字符的串。
- 空格串：只包含空格的串。
- 子串：串中任意连续字符组成的字符串叫作该串的子串。
- 原串：通常也称为主串。

字符串的存储结构与线性表相同，也有顺序存储和链式存储两种。但总的来说，链式存储不如顺序存储灵活，在性能方面也不如顺序存储结构好。

## 树和二叉树

树是由结点和边组成的，**不存在环**的一种数据结构。树结构满足递归定义，剔除掉根节点得到的若干个子结构也是树，通常称作子树。

### 二叉树

在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。在二叉树中又有两个特殊的类型。

- 满二叉树：定义为除了叶子结点外，所有结点都有 2 个子结点。
- 完全二叉树：定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。

存储二叉树有两种办法，一种是基于指针的链式存储法；一种是基于数组的顺序存储法：

- 链式存储法，也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针
- 顺序存储法，就是按照规律把结点存放在数组里

### 树的基本操作

遍历：

- 前序遍历，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树。
- 中序遍历，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树。
- 后序遍历，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。

### 二叉查找树

二叉查找树（也称作二叉搜索树）具备以下几个的特性：

- 在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。
- 在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。
- 在二叉查找树中，会尽可能规避两个结点数值相等的情况。 -对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。

## 哈希表

哈希表名字源于 Hash，也可以叫作散列表。

哈希表的设计采用了函数映射的思想，将记录的存储位置与记录的关键字关联起来。这样的设计方式，能够快速定位到想要查找的记录，而且不需要与表中存在的记录的关键字比较后再来进行查找。

哈希表相对于其他数据结构有很多的优势。它可以提供非常快速的插入-删除-查找操作，无论多少数据，插入和删除值需要接近常量的时间。在查找方面，哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。

哈希表也有一些不足。哈希表中的数据是没有顺序概念的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。在数据处理顺序敏感的问题时，选择哈希表并不是个好的处理方法。同时，哈希表中的 key 是不允许重复的，在重复性非常高的数据中，哈希表也不是个好的选择。
