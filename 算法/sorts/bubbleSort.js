/**
 * 冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
 */

// 算法分析
// 最佳情况 O(n)
// 最差情况 O(n2)
// 平均情况 O(n2)

/**
 * <1>.比较相邻的元素。如果第一个比第二个大，就交换它们两个；
 * <2>.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的 元素应该会是最大的数；
 * <3>.针对所有的元素重复以上的步骤，除了最后一个；
 * <4>.重复步骤1~3，直到排序完成。
 **/

function bubbleSort1(arr) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    for (let j = 0; j < len - 1 - i; j++) {
      // 每次外循环取到一个大值，内循环count-1
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}

/**
 * 设立flag：pos，每次循环开始重置，发生交换则记录交换位置，作为下一次循环的终点，直到无交换行为，数据有序
 */
// 每次交换都保证找到一个大值，记录最后一次交换位置，此位置后的可以确定为排序过的
// 注意，此时pos在每次循环开始被重置为0，这意味着如果某次循环为发生交换，则下次循环条件就不成立了，提前结束循环。
function bubbleSort2() {
  let len = arr.length - 1;
  while (len > 0) {
    let pos = 0;
    for (let j = 0; j < len; j++) {
      if (arr[j] > arr[j + 1]) {
        pos = j; // 记录交换位置索引，该索引后的数都是已排序的
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
    len = pos; // 当没有交换行为pos为0，跳出循环
  }
  return arr;
}

var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(bubbleSort2(arr)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
